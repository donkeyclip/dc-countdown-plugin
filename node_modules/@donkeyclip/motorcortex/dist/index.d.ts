import { transform } from 'typescript';
import { ValidationSchema } from 'fastest-validator';

type CheckResult = {
    result: true;
    execute?: () => void;
} | {
    result: false;
    errors: any[];
};
declare class Channel {
    context: any;
    getIncidentById: any;
    runTimeInfo: any;
    constructor(props: {
        runTimeInfo: any;
        context: any;
        getIncidentById: any;
    });
    static get type(): string;
    static set type(type: string);
    onInitialise(): void;
    _resize(_durationFraction: number): void;
    /**
     * @param {array} incidents - A collection of Incidents in the form:
     * {
     *  millisecond
     *  incident
     *  id
     * }
     * @returns either:
     *   {
     *       result:true,
     *       execute: // an array of functions that when executed it will add the Incidents on the Channels
     *   }
     *   or
     *   {
     *       result: false,
     *       errors
     *   }
     */
    addIncidents(incidents: Parameters<typeof this.checkAddition>[0]): {
        result: boolean;
        errors: any;
        execute?: undefined;
    } | {
        result: boolean;
        execute: any;
        errors?: undefined;
    };
    /**
       * It initially checks if the edit is allowed and if it is it returns an array of executable functions
       * that apply the change
       * @param {array} incidents - the list of the incidents to edit in an array format [object, object, ...]
       * @param {number} millisecondsDelta - the milliseconds delta to apply to the incidents
       * @returns {object} -
       * either:
       {
          result: true,
          execute: // array of functions to be executed in order to apply the edit
       }
       or
       {
           result: false,
           errors: // an array including all the errors / conflicts found on edit
       }
      */
    editIncidents(incidents: any, millisecondsDelta: number): {
        result: boolean;
        errors: any;
        execute?: undefined;
    } | {
        result: boolean;
        execute: any;
        errors?: undefined;
    };
    /**
       * Method to remove incidents
       * @param {array} incidents - the ids of the incidents to remove in an array format
       * @param {object} props
       * @returns {object} -
       * either:
       {
          result: true,
          execute: // array of functions to be executed in order to apply the edit
       }
       or
       {
           result: false,
           errors: // an array including all the errors / conflicts found on edit
       }
      */
    removeIncidents(incidents: any, props?: {}): {
        result: boolean;
        errors: any;
        execute?: undefined;
    } | {
        result: boolean;
        execute: any;
        errors?: undefined;
    };
    /**
     * This method is invoked whenever a Clip with exits a context loading waiting. All Channels
     * that extend Channel can rewrite this method accordingly
     * @param {string} _contextId - The id of the context of the Clip Copy according to which
     *      we are going to recalc the scratch values
     * */
    recalcScratchValues(_contextId?: string): void;
    /**
       * On this method the user defines the specific rules that apply on the plugin itself and on the Incidents of the plugin itself
       * The method should either return {result: true} or {result: false, errors:[{error-object}]}, where error-object has the structure:
       *  {
              incident: // reference to the Incident object that has bee discarded
              error: // text
          }
    **/
    checkAddition(_incidents: {
        id: string;
        millisecond: number;
        incident: MonoIncident;
    }[]): CheckResult;
    checkEdit(_incidentsArray: any, _millisecondsDelta: any): CheckResult;
    checkDelete(_incidentIds: any, _props: any): CheckResult;
    checkResizedIncidents(_incidents: any): CheckResult;
    moveTo(_from: any, _to: any, _contextId: any, forceReset: boolean): void;
}

declare class AudioNodeSet {
    gainNode: GainNode;
    input: GainNode | StereoPannerNode;
    output: GainNode;
    pannerNode: StereoPannerNode | undefined;
    constructor();
    connect(master: AudioNode): void;
    disconnect(): void;
}

declare class PubSub {
    subscribers: Array<(arg: unknown) => void>;
    constructor();
    sub(id: string, method: (arg: unknown) => void): void;
    pub(argument?: unknown): void;
}
/**
 * Specs:
 * AudioContext Handler keeps all the audio sources.
 * The audio sources are passed in the following format:
 * - src (the source of the sound)
 * - base64 (boolean, defaults to false. If the sound is base64 it's been treated
 *      in a different way)
 * - id (must be unique)
 * - classes (an array of belonging classes)
 *
 * The SoundContextHanlder creates a media element of the following format:
 * media: {
 *  src
 *  id
 *  classes
 *  base64
 *  buffer
 *  nodes: {
 *      stereo
 *      highpass
 *      lowpass
 *      gain
 *      audioNodeSet
 *  }
 * }
 *
 * Finally the SoundContextHandler has its own nodes (the master) which look like this:
 * master: {
 *      stereo
 *      highpass
 *      lowpass
 *      gain
 * }
 * */
type AudioSource = {
    mcid?: string;
    id: string;
    src: string;
    classes: string[];
    base64?: boolean | string;
    pubSub?: PubSub;
    soundLoaded?: boolean;
    startValues?: any;
    buffer?: AudioBuffer;
    audioNodeSet?: AudioNodeSet;
};

declare enum _DIRECTIONS {
    _UP = "up",
    _DOWN = "down"
}

declare abstract class Node extends Leaf {
    calculatedDuration: number;
    runTimeInfo: NonNullable<LeafProps['runTimeInfo']>;
    constructor(props: ConstructorParameters<typeof Leaf>[0]);
    /**
     * We want to keep our duration as number and avoid getter because of performance.
     * For this each time the duration must be recalculated we can call this method
     */
    resetDuration(): void;
    get duration(): any;
    set duration(milliseconds: any);
    /**
     *
     * @param {object} payload - an object with the childId key. This object is provided on addition actions
     * so it executes recalc with better performance
     */
    _calculateDuration(payload?: {
        childId: string;
    }): boolean;
    handleRecalcDuration(target: any, payload: any): boolean | PutMessageOnPipeRes | PutMessageOnPipeRes[];
    getLeafById(id: string, onlyDirectChild?: boolean): Leaf | null;
    getLeafPosition(id: keyof InstanceType<typeof Node>['children']): any;
    handleGetLeafPosition(target: any, payload: {
        id: string;
    }): any;
    checkAddition(leaf: any, position: any): {
        result: boolean;
        reason: string;
    } | {
        result: boolean;
        reason?: undefined;
    };
    addChild(leaf: any, position: any): {
        result: boolean;
    } | {
        result: boolean;
        reason: string;
    };
    checkRemoveChild(id: any): {
        result: boolean;
        reason: string;
    } | {
        result: boolean;
        reason?: undefined;
    };
    removeChild(id: any): {
        result: boolean;
    };
    checkEditPosition(id: any, position: any): {
        result: boolean;
        reason: string;
    } | {
        result: boolean;
        reason?: undefined;
    };
    editPosition(id: any, position: any, bypassRecalcDuration?: boolean): {
        result: boolean;
    } | undefined;
    /**
      The expected result of this method depends on the direction of the message
      The direction might either be _UP or _DOWN.
      In the case of _UP the expected result is identical as on Leaf:
      {
          response: an object the structure of which depends on the name of the message
              and maybe even on the payload
          responder: a direct reference to the lead that actually responded
      }
      In the case of _DOWN though, where multiple Leafs might be eligible in the tree
      for handling the message the result is on the form:
      [
          {
              response: an object the structure of which depends on the name of the message
                  and maybe even on the payload
              responder: a direct reference to the lead that actually responded
              positionDelta: the position delta of the responder compared to the requester
          }
      ]
      */
    putMessageOnPipe(name: PutMessageOnPipeNames, payload: Record<string, unknown>, target: string | null | Record<string, any>, options?: {
        selfExecute?: boolean;
        direction?: (typeof _DIRECTIONS)[keyof typeof _DIRECTIONS];
        positionDelta?: number;
    }): PutMessageOnPipeRes | PutMessageOnPipeRes[];
    putMsgOnPipeWithResult(name: Parameters<typeof this.putMessageOnPipe>[0], payload: Parameters<typeof this.putMessageOnPipe>[1], target: Parameters<typeof this.putMessageOnPipe>[2], options?: {
        selfExecute?: boolean | undefined;
        direction?: _DIRECTIONS | undefined;
        positionDelta?: number | undefined;
    } | undefined): {
        result: boolean;
    };
    handleGetPositionOnPyramidion(target: any, payload: {
        id: string;
        delta: number;
    }): string | number | boolean | {
        result: boolean;
    } | undefined;
}

declare abstract class Group extends Node {
    hasIncidents: boolean;
    instantiatedCopiesContexts: any;
    constructor(_attrs: any, props: ConstructorParameters<typeof Node>[0]);
    /**
     * called when the group gets initialised
     */
    onGroupInitialise(): void;
    handleAddIncident(target: any, payload: any): any;
    handleMoveIncident(target: any, payload: any): string | Leaf;
    /**
     * As Group acts as a transparent layer in terms of checks handleRemoveIncident
     * and handleMoveIncident happens to have the exact same definition
     */
    handleRemoveIncident: (target: any, payload: any) => string | Leaf;
    handleResize(target: any): string | this;
    removeChild(id: string | number): {
        result: boolean;
    };
    /**
     * Returns an object that has the key of the npm plugin name the Channel of which manages the specific Incident
     * With the same logic all Incidents that belong to this Group as categorised by plugin / channel on the same object
     */
    getIncidentsByChannel(adjustMillisecond?: number, parentMillisecond?: number | undefined | null): {
        [x: string]: {
            millisecond: number;
            parentMillisecond: number | null | undefined;
            incident: ExtendableClip | Group;
            id: string | undefined;
        }[];
    };
    lastWish(): void;
}

declare class DescriptiveGroup extends Node {
    static Incident: typeof Group | typeof BrowserClip;
    static plugin_npm_name: string;
    static version: string;
    static Channel: typeof Channel;
    static ClassName: string;
    static isGroup: boolean;
    static attrsValidationRules: null;
    static propsValidationRules: any;
    passiveAddition?: boolean;
    constructor(attrs?: LeafProps | undefined, props?: ConstructorParameters<typeof Node>[0]);
    _calculateDuration(forceGroups?: any): boolean;
    _rebuildTree(): void;
    _buildTree(): void;
    buildTree(): void;
    get duration(): any;
    set duration(milliseconds: any);
    manageEditAttrProps(newAttrs: any, type: keyof this): any;
    detachFromParent(): void;
    get inheritedSelector(): string | null;
    set inheritedSelector(value: string | null);
    get selectorToPassToChildren(): any;
    /**
     * The purpose of this method is to export a portable definition that can be
     * later used in order to rebuild the Inicdent at any time
     */
    exportDefinition(): {
        ClassName: any;
        version: any;
        plugin: any;
        plugin_npm_name: any;
        attrs: any;
        props: any;
        incidents: Record<string, {
            id: string;
            position: any;
            leaf: any;
        }>;
        duration: any;
    };
    /**
     * The purpose of this method is to export an object with "live" / real reference
     * to the Class of the Incident so it can directly by used for Clip creation
     * */
    exportLiveDefinition(includeId?: boolean): Definition;
    addIncident(descriptiveIncident: any, position?: any, options?: {
        check: boolean;
    }): any;
    /**
     * @param input - can either be object or id
     * */
    moveIncident(input: any, position: any): any;
    removeIncident(input: any): any;
    /** ************************* HANDLING METHODS ****************************** */
    handleCheckForClip(_target: any, _payload: any): boolean | string;
    handleCheckAddition(target: any, payload: any): string | {
        result: boolean;
    };
    handleCheckMove(target: any, payload: any): string | {
        result: boolean;
    };
    handleCheckDeletion(target: any, payload: any): string | {
        result: boolean;
    };
    handleCheckResize(target: any, payload: any): string | {
        result: boolean;
    };
    handleSetDurationDynamic(target: any, payload: any): void;
}

declare abstract class Playable extends DescriptiveGroup {
    isTheRootClip?: boolean;
    listeners: Record<string, {
        funct: (ms: number, newState: any, options?: any) => void;
        onlyOnStateChange?: boolean | undefined;
        threshold: number;
        cavaDelta: number;
        roundTo: number;
    }>;
    previousTimeStamp: number;
    speed: number;
    pauseMoment: number;
    abstract onProgress(fraction: number, millisecond: number): void;
    constructor(attrs: ConstructorParameters<typeof DescriptiveGroup>[0], props: ConstructorParameters<typeof DescriptiveGroup>[1]);
    /** ********************* execution methods  *********************
     *************************************************************** */
    /**
     *
     * @param {string} newState: the new state
     * @param {object} options: an optional options object that might provide extra info for the status change
     * @private
     */
    _setState(newState: StateStatus, options?: {}): void;
    handleSetState(_target: any, payload: {
        newState: StateStatus;
        options?: any;
    }): void;
    play(debug?: boolean): void;
    pause(): void;
    arm(): void;
    complete(): void;
    stop(): void;
    /**
     *
     * @param {object} options: An optional options object for the block.
     * Currently it supports the key "except" which can hold the id of an Incident that we want to exclude from the block
     */
    block(options?: {
        exception?: any;
    }): void;
    onPlay(): void;
    onWait(): void;
    playableProgress(fraction: number, millisecond: number): boolean;
    set executionSpeed(speed: string | number);
    step(timestamp: number, debug?: boolean): void;
    /**
        By subscribing a module can get notified about changes on the Clip's time
        subscribe method subscribes a function to the time change dispatcher. As Clip uses requestAnimationFrame for its timing
        each cycle / step gets the current time and subtracts the previous time so it know how many milliseconds has elapsed
        since last step. Subscribers can set to get informed about time changes only if the delta is greater than a given
        number (e.g. greater than 300ms). That property is passed as the second argument "threshold".
        Finally if any of the subscribers want the Scene to provide back a rounded number of the milliseconds. Options:
          - 1 (round it on its actual units
         - 10 (round it on tenths)
         - 100 (round it on hundreds)
         - 1000 (round it on thousands)
        the first argument provides an id to the listener for future reference (deletion etc)
        the second argument is a function that takes two arguments: millisecond, state (current millisecond of the Scene
        and the state of it  */
    subscribe(id: string, funct: (ms: number, state: string, options: any) => void, threshold: number, roundTo: number, onlyOnStateChange?: boolean): void;
    unsubscribe(id: any): void;
    subscribeToDurationChange(funct: any): boolean;
}

declare class AudioClip extends ExtendableClip {
    audioNodeSet: AudioNodeSet;
    parentClipContext: Context;
    constructor(attrs: ConstructorParameters<typeof ExtendableClip>['0'], props: ConstructorParameters<typeof ExtendableClip>['1'] & {
        initParams: any;
    });
    /**
     * As AudioClip does not accept a selector and does not get analysed to ContextAwareIncidents, the mechanism that
     * triggers recalcDuration to the parents does not get executed. For this we overwrite its parent's method so
     * whenever there is a change on the duration the parents get informed as well
     * @param target
     * @param payload
     */
    handleRecalcDuration(target: any, payload: any): boolean;
    onProgress(fraction: number, milliseconds: number, contextId?: string, forceReset?: boolean): void;
    _onGetContextOnce(parentClipContext: Context): void;
    lastWish(): void;
    get volume(): number;
    set volume(vol: number);
}

type MCFont = {
    type: 'google-font';
    src: string;
}[];

/**
 * It's the Browser version of a MotorCortex Clip. BrowserClip extends ExtendableClip and, as
 * it should, it defines its ownContext on its constructor (see ExtendableClip
 * for details re this.ownContext property). Also, it renders itself either on
 * iframe or via shadow Browser, depending on browser support.
 * BrowserClip, via the use of the customEntities, provided by ExtendableClip, can be
 * used to create other kinds of Clips (not HTML/Browser), such as webGL that all run on
 * the browser, on a given Browser elment should be implemented by extending this Class.
 * The rest can be handled by customEntities, check on documentation how to use them.
 * For Clips that do not live on the browser developers can extend ExtendableClip,
 * follow the paradigm of BrowserClip and create a Clip for a totally different platform.
 *
 **/
declare class BrowserClip extends ExtendableClip {
    constructor(attrs: any, props: (LeafProps & {
        html?: string | undefined;
        css?: string | undefined;
        fonts?: MCFont | undefined;
        initParams?: InitParams | undefined;
    }) | undefined, DescriptiveIncident: ConstructorParameters<typeof ExtendableClip>['2']);
    onAfterRender(): void;
    get html(): string;
    get css(): string;
    get fonts(): never[];
    get rootElement(): HTMLElement | undefined;
    /**
     * exportConstructionArguments is a method already defined and provided by ExtendableClip.
     * Though BrowserClip overwrites it as it wants the exportedConstructionArguments to reflect
     * the changes already made on the actual DOM.
     * @return {{attrs: Object, props: (*&{host: undefined, html: (string|*)})}}
     */
    exportConstructionArguments(): {
        attrs: any;
        props: any;
    };
}

declare class NullClip {
    isNullClip?: boolean;
    context: Context;
    constructor();
    get duration(): number;
    set duration(_duration: number);
    addIncident(): CheckResult;
    moveIncident(): CheckResult;
    removeIncident(): CheckResult;
    resizeIncident(): CheckResult;
    getIncidentsByChannel(): {};
    flash(): void;
    _resize(): void;
    onProgress(): void;
    renderOnDOM(): void;
    removeFromDOM(): void;
    get volume(): number;
    set volume(_volume: number);
    setVolume(): void;
}

declare class ClipClone {
    id: any;
    ownClip: any;
    realClip: any;
    runTimeInfo: any;
    constructor(dna: any);
    onProgress(fraction: any, milliseconds: any, forceReset?: boolean): void;
}

type AUDIO_OPTIONS = 'on' | 'only' | 'off';
/**
 * A number, or a string containing a number.
 * @typedef {Object} ClipProps
 * @property {string} props.html - the html template to render
 * @property {string} props.css - the css template of the isolated tree
 * @property {HTMLElement} props.host - an Element object that will host the isolated tree
 * @property {object} props.containerParams - an object that holds parameters to affect the container of the isolated tree, e.g. width, height etc
 * @property {object} [props.initParams] - optional / the initialization parameters that will be passed both on the css and the html templates in order to render
 **/
interface ClipProps {
    html: LeafProps['html'];
    css: LeafProps['css'];
    host?: HTMLElement | undefined | null;
    containerParams?: Record<string, any>;
    initParams?: InitParams;
    duration?: number;
    audio?: string;
    fonts?: {
        type: string;
        src: string;
    }[];
    selector?: string;
    initParamsValidationRules?: string | Record<string, any>;
    audioSources?: LeafProps['audioSources'];
}
/**
 * Along with the expected props for the Clip on the props support the audio key.
 * The audio can take one of the 3 following values:
 * - "on": The Clip has audio enabled
 * - "off": The Clip has audio disabled
 * - "only": The Clip is only audio
 *
 * Also, in the case audio is on or only the user should pass the "audioSources"
 * key containing all the audio sources they want to pass on the WebAudio Context
 * of their clip. Please check AudioClip for details on the expected format
 * */
declare class HTMLDescriptiveClip extends Playable {
    mustHaveNullClip?: boolean;
    initParams: ClipProps['initParams'];
    volumeChangeSubsribers: Record<string, (arg: number) => void>;
    audio?: string;
    audioClip: AudioClip | NullClip;
    statusBeforeBlock?: StateStatus;
    nonBlockingErrorClip?: boolean;
    constructor(attrs: ConstructorParameters<typeof Playable>[0] & ClipProps, props?: (ConstructorParameters<typeof Playable>[1] & ClipProps) | null | undefined);
    static isClip: boolean;
    static Incident: typeof BrowserClip;
    static plugin_npm_name: string;
    static version: string;
    static Channel: typeof ClipChannel;
    static ClassName: string;
    static propsValidationRules: any;
    get selectorToPassToChildren(): null;
    get inheritedSelector(): any;
    set inheritedSelector(value: any);
    get html(): string;
    get css(): string;
    get fonts(): never[];
    get audioSources(): never[];
    resolveAudioSources(audioSources: any): any;
    detachFromParent(): void;
    get duration(): number;
    set duration(milliseconds: number);
    systoleDiastole(durationFraction: any): void;
    exportLiveDefinition(includeId?: boolean): Definition;
    _buildTree(): void;
    /**
     * When the resize command is given directly to a HTMLDescriptiveClip no checks
     * need to be performed.
     * HTMLDescriptiveClip directly invokes the _resize method of ExtendableClip which
     * resizes the full clip
     */
    resize(newSize: number): {
        result: boolean;
    } | {
        result: boolean;
        reason: string;
    };
    manageEditAttrProps(newAttrs: any, type: any): {
        result: boolean;
        errors: string[];
    };
    /** ************************* HANDLING METHODS ****************************** */
    handleCheckForClip(_target: any, _payload: any): boolean;
    handleGetElements(target: any, payload: any): any;
    handleCheckAddition(target: any, payload: any): any;
    handleCheckMove(_target: any, payload: any): any;
    handleCheckDeletion(_target: any, payload: any): any;
    handleCheckResize(_target: any, payload: any): any;
    handleFlash(_target: any, payload: any): string | void;
    /**
     * We overwrite exportDefinition of Groups so we add duration on the props
     * of the Clip
     */
    exportDefinition(): {
        ClassName: any;
        version: any;
        plugin: any;
        plugin_npm_name: any;
        attrs: any;
        props: any;
        incidents: Record<string, {
            id: string;
            position: any;
            leaf: any;
        }>;
        duration: any;
    };
    /** **************** BLOCKING WAITINGS HANDLING ************************* */
    /** ******************************************************************** */
    handleSetBlock(_target: any, payload: BlockPayload): string | undefined;
    handleUnBlock(target: any, payload: any): string | undefined;
    stop(): void;
    /** ******************************************************************** */
    /** ******************************************************************** */
    onProgress(fraction: number, millisecond: number): void;
    /** ********************************************************** */
    paste(host: any): ClipClone | null;
    flash(): void;
    get volume(): number;
    /**
     *
     * @param {number} vol: a number from 0 to 1
     * @returns {{result: boolean}|{result: boolean, errors: [{type: string}]}}
     */
    setVolume(vol: number): {
        result: boolean;
        errors: {
            type: string;
        }[];
    } | {
        result: boolean;
        errors?: undefined;
    };
    /**
     * This method provides the ability to attach MediaElementAudioSourceNodes to the DI's audioClip's input
     * The method is mainly used by BrowserClips that have some kind of audio output which should be heard on playback
     * (such as the VideoClip of the video plugin)
     * @param {MediaElementAudioSourceNode} source
     */
    attachMediaElementSource(source: Parameters<AudioContext['createMediaElementSource']>[0]): void;
    /**
     *
     * @param {string} id: the unique subscription id
     * @param {function} funct: the callback function to listen to volume changes
     */
    volumeChangeSubscribe(id: string, funct: () => void): any;
    volumeChangeUnsubscribe(id: string): number;
    handleVolumeChangeSubscribe(_target: any, payload: {
        type: any;
        id: string | number;
        funct: any;
    }): string | number | false;
}

/**
 *
 * Clip from definition takes a definition object and returns a full Descriptive
 * Representation / creation of the Clip. As soon as the Clip is hosted, immediately
 * the real Clip will also be rendered.
 *
 * definition: {
 *     Class: <The Class>,
 *     attrs: <attrs>,
 *     props: <props>,
 *     incidents: { // this exists only in the case of a Group or a Clip
 *         <id>:{
 *           id: <id>,
 *           position> <position>,
 *           leaf: <definition>
 *         },
 *         ...
 *     }
 * }
 */
type Class<T = any> = new (...args: any[]) => T;
type Definition = {
    Class: typeof HTMLDescriptiveClip | Class;
    attrs: ConstructorParameters<typeof HTMLDescriptiveClip>['0'];
    props: ConstructorParameters<typeof HTMLDescriptiveClip>['1'];
    incidents?: {
        [id: string]: {
            id?: typeof id;
            position: unknown;
            leaf: Definition;
        };
    };
};
declare function constructIncident(definition: Definition): HTMLDescriptiveClip | CheckResult;

declare const easing: {
    readonly linear: (fraction: any) => any;
    readonly easeInQuad: (fraction: any) => number;
    readonly easeOutQuad: (fraction: any) => number;
    readonly easeInOutQuad: (fraction: any) => number;
    readonly easeInCubic: (fraction: any) => number;
    readonly easeOutCubic: (fraction: any) => number;
    readonly easeInOutCubic: (fraction: any) => number;
    readonly easeInQuart: (fraction: any) => number;
    readonly easeOutQuart: (fraction: any) => number;
    readonly easeInOutQuart: (fraction: any) => number;
    readonly easeInQuint: (fraction: any) => number;
    readonly easeOutQuint: (fraction: any) => number;
    readonly easeInOutQuint: (fraction: any) => number;
    readonly easeInSine: (fraction: any) => number;
    readonly easeOutSine: (fraction: any) => number;
    readonly easeInOutSine: (fraction: any) => number;
    readonly easeInExpo: (fraction: any) => number;
    readonly easeOutExpo: (fraction: any) => number;
    readonly easeInOutExpo: (fraction: any) => any;
    readonly easeInCirc: (fraction: any) => any;
    readonly easeOutCirc: (fraction: any) => number;
    readonly easeInOutCirc: (fraction: any) => number;
    readonly easeInElastic: (fraction: any) => any;
    readonly easeOutElastic: (fraction: any) => any;
    readonly easeInOutElastic: (fraction: any) => any;
    readonly easeInBack: (fraction: any) => number;
    readonly easeOutBack: (fraction: any) => number;
    readonly easeInOutBack: (fraction: any) => number;
    readonly easeInBounce: (fraction: any) => number;
    readonly easeOutBounce: (fraction: any) => number;
    readonly easeInOutBounce: (fraction: any) => number;
};

type StateStatus = 'idle' | 'paused' | 'armed' | 'transitional' | 'blocked' | 'playing';
type PutMessageOnPipeNames = 'setBlockingWaiting' | 'retBlockingWaiting' | 'setBlock' | 'unBlock' | 'setDurationDynamic' | 'recalcDuration' | 'setState' | 'getElements' | 'getLeafPosition' | 'checkForClip' | 'checkDeletion' | 'checkMove' | 'checkAddition' | 'checkResize' | 'volumeChangeSubscribe' | 'checkForInvalidSelectors' | 'contextLoaded' | 'resize' | 'removeIncident' | 'flash' | 'moveIncident' | 'addIncident' | 'addContext' | 'getPositionOnPyramidion';
type LeafProps = {
    root?: boolean;
    html: string | ((initialParameters: InitParams) => string);
    css: string | ((initialParameters: InitParams) => string);
    audioSources?: AudioSource[] | undefined;
    easing?: keyof typeof easing;
    runTimeInfo?: {
        currentMillisecond: number;
        state?: StateStatus;
    };
    id?: string;
    name?: string | null;
    selector?: string;
    host?: HTMLElement;
    delay?: number | string;
    duration?: number | string;
    hiatus?: number | string;
    repeats?: number;
    animatedAttrs?: Record<string, unknown>;
    containerProps?: Record<string, any>;
    originalDims?: Record<string, any>;
};
type PutMessageOnPipeRes = {
    response?: boolean | string | {
        result: boolean;
    };
    responder?: Leaf | null;
    positionDelta?: number;
};
type BlockPayload = {
    id: string | number;
    options: {
        exceptional: any;
    };
    incidentId: any;
};
type ConstructionIngredients = {
    incidentId: any;
    attrs?: any;
    props: any;
    Incident?: any;
    plugin_npm_name: any;
    Channel: any;
    DescriptiveIncident?: any;
};
type InitParams = Record<string, any>;
declare abstract class Leaf extends RealIncidentBase {
    constructionIngredients: ConstructionIngredients;
    mcid: string;
    easing: (fraction: number) => number;
    plugin_channel_class: typeof Channel;
    attributesStaggers: any;
    propsStaggers: any;
    dynamicDurationValue: any;
    blockingWaitings: Record<string, BlockPayload>;
    _duration?: number;
    realClip: any;
    originalContextKey?: string | number;
    contexts: Record<string, Context>;
    attrs: any;
    _inheritedSelector: string | null;
    isNode: boolean;
    passive?: boolean;
    parentNode: any;
    props: any;
    children: Record<string | number, {
        id: string;
        position: number;
        leaf: any;
    }>;
    abstract exportLiveDefinition(_includeID?: boolean): Definition;
    abstract manageEditAttrProps(_newAttr: any, _type: keyof this): CheckResult;
    constructor(props?: LeafProps);
    get name(): string;
    set name(newName: string);
    get inheritedSelector(): string | null;
    set inheritedSelector(_selector: string | null);
    get delay(): number;
    set delay(val: number);
    get hiatus(): number;
    set hiatus(val: number);
    get repeats(): number;
    set repeats(val: number);
    /**
     *
     * @param {boolean} triggerUp - if provided to true the reset triggers reset duration on the
     * Leaf's parents too. Defaults to false
     */
    resetDuration(triggerUp?: boolean): void;
    /**
     * the full duration of the Leaf taking in consideration all: delay, duration, hiatus and
     * repeats factor
     * */
    get duration(): number;
    /**
     * the setter sets the overall duration of the Leaf by altering all
     * delay, duration and hiatus properties of it
     * */
    set duration(milliseconds: number);
    /**
     * @param {Number} newDuration
     * setNewDuration method sets the new FULL duration as it derives from the
     * delay, duration, hiatus and repeats factors
     * */
    setNewDuration(newDuration: number): void;
    systoleDiastole(durationFraction: number): void;
    get hasParent(): boolean;
    attachToNode(node: any): void;
    detachFromParent(): void;
    /**
    @param {string} name - the name of the message
    @param {object} payload - the payload of the message
    @param {object} target - specifies the target of the message in a key-value pairs object
    @param {object} options - in the form:
    @param {_DIRECTIONS} options.direction
    @param {boolean} options.selfExecute - either true which means the Leaf should try to handle the message itself or false which means the Leaf should directly forward the message to its parent
    @returns {({'response': boolean,'responder': Class|null}|[{'response': boolean,'responder': Class|null,'positionDelta':Number|null}])} The expected result of this method is on the form:
    {
        response: an object the structure of which depends on the name of the message
            and maybe even on the payload
        responder: a direct reference to the lead that actually responded
        (only valid for direction _DOWN) positionDelta: the position delta of the responder compared to the requester
    }
    * */
    putMessageOnPipe(name: PutMessageOnPipeNames, payload: any, target: any, options?: {
        direction?: _DIRECTIONS;
        positionDelta?: number;
        selfExecute?: boolean;
    }): PutMessageOnPipeRes | PutMessageOnPipeRes[];
    bypass(): string;
    get positionOnPyramidion(): string | number | boolean | {
        result: boolean;
    } | undefined;
    getPositionOnPyramidion(delta?: number): string | number | boolean | {
        result: boolean;
    } | undefined;
    editAttributes(newAttrs: any): {
        result: true;
        execute?: (() => void) | undefined;
    } | {
        result: boolean;
        errors: any;
    } | {
        result: boolean;
        errors?: undefined;
    };
    editProperties(newProps: any): {
        result: boolean;
        errors?: undefined;
    } | {
        result: boolean;
        errors: any;
    } | {
        result: true;
        execute?: (() => void) | undefined;
    };
    resize(newSize: any, options?: {
        check: boolean;
    }): string | boolean | {
        result: boolean;
    } | {
        result: boolean;
        reason: string;
        meta?: undefined;
    } | {
        result: boolean;
        meta: {
            unprocessed: boolean;
        };
        reason?: undefined;
    } | undefined;
    clone(attrs?: {}, props?: {}): HTMLDescriptiveClip | CheckResult;
    selector(): any;
    getElements(_selector: string): string | boolean | any[] | {
        result: boolean;
    } | undefined;
    setupDynamicValues(): {
        attrs: {
            expression?: any;
            initParams?: InitParams;
        };
        props: {
            expression?: any;
            initParams?: InitParams;
        };
    };
    _calculateDuration(payload?: {
        childId: string;
    }): void;
}

/**
 * This Class acts more as an Abstract Class. Developers that want to create new Clip types
 * need to extend this Class and implement the methods listed here
 */
type MCElement = {
    id: string;
    entity?: any;
    classes: any[];
    customEntity?: boolean;
};
type MCElementLookupRecord = Record<string, MCElement>;
type Context = {
    getElements: (selector: string) => MCElement[];
    getElementSelectorByMCID: (mcid: string) => string | void;
    getElementByMCID: (mcid: string) => MCElement;
    setCustomEntity: (id: string, entity: any, classes?: never[]) => boolean;
    getMCID: (element: MCElement) => any;
    setMCID: (element: MCElement, mcid: string) => void;
    unmount?: () => void;
    initParams?: InitParams;
    rootElement?: HTMLElement;
    fragment?: boolean;
    audio?: boolean;
    contextLoaded?: boolean;
    audioContext?: AudioContext;
    masterNode?: AudioNodeSet;
    document?: Document;
    window?: Window;
    isHostedClip?: boolean;
};
declare class ExtendableContextHandler {
    _targetHost: any;
    context: Context;
    customEntities: MCElementLookupRecord;
    elementsByMCID: MCElementLookupRecord;
    id?: string;
    props: any;
    /**
     * The constructor makes sure it assigns all methods of the ContextHandler to
     * the context object it creates.
     */
    constructor(props?: any);
    setContext(obj?: any): void;
    /**
     * _getElements method is not overwritten by the child Classes. What it
     * does is to make sure the provided selector is valid and handle the case
     * of the special selector (starting with "!") which returns custom entities
     * @private
     */
    _getElements(selector: string): any[];
    /**
     * Acts as a proxy before forwarding the call the getMCID implementation
     * of each ContextHandler, after it has first checked customEntities
     * @param {element} element: Given an element it provides back its mcid
     * @return {string}: The MC id of the provided element
     * @private
     */
    _getMCID(element: any): string;
    /**
     * Given an mcid the ContextHandler will provide a string selector that selects the
     * element that has this mcid
     * @param {string} mcid
     * @return {string}
     * @private
     */
    _getElementSelectorByMCID(mcid: string): string | void;
    /**
     * Given an mcid ContextHandler will return the element that has it
     * @param {string} mcid
     */
    getElementByMCID(mcid: string): any;
    /**
     * @param {string} selector: A selector string to select the elements
     * @return {array}: An array of all elements that apply to the selector
     */
    getElements(selector: string): any[];
    /**
     * @param {element} element: Given an element it provides back its mcid
     * @return {string}: The MC id of the provided element
     */
    getMCID(_element: any): string | void;
    /**
     * Given an element and an mc id the ContextHandler assigns the mc id to the element
     */
    setMCID(_element: any, _mcid: string): void;
    /**
     * Given an mcid the ContextHandler will provide a string selector that selects the
     * element that has this mcid
     */
    getElementSelectorByMCID(_mcid: string): string | void;
    /**
     * This method unmounts the Clip
     */
    unmount(): void;
    /**
     * Sets a custom entity. Custom entities are analysed on docs.motorcortex.com
     * @param {string} id: The id of the custom entity
     * @param {any} entity: The entity itself. Can be any type
     * @param {array} classes: A list of classes the user wants to assign to its custom entity
     * @return {boolean}
     */
    setCustomEntity(id: string, entity: any, classes?: string[]): boolean;
}

declare class IReMa {
    _bwExecutionSubscribers: any;
    _currentPeriod: any;
    _executionSubscribers: any;
    _nextIterationLanes: any;
    subPeriod: any;
    constructor();
    reset(): void;
    executionSubscribers(contextid: any, direction: any): any;
    subscribe(contextid: any, direction: any, step: any, laneid: any, lane: any): void;
    nextIterationLanes(contextid: any, lanes: any): any;
    setNextIterationLanes(contextid: any, lanes: any): void;
    currentPeriod(contextid: any): any;
    setCurrentPeriod(contextid: any, period: any): void;
}

declare class LanesHandler {
    /**
        Keeps an indexing of the lanes each Animation belongs to. The form is the following:
        belongingLaneKeysByAnimationId: {
            <animation_id>: [laneKey1, laneKey2, ...],
            <animation_id>: [laneKey2, laneKey3, ...],
            ...
        }
    */
    belongingLaneKeysByAnimationId: any;
    comboAttributes: Record<string, any>;
    incidentsById: Record<string, any>;
    lanes: any;
    /**
     * An object that will will hold the index of the last animated item of the lane per contextid
     * This information is useful for the faster identification of the items that should
     * be animated when progressing from ms1 to ms2
     * The information will be kept in the form:
     * {
     *   <contextid>: {
     *    {
     *      <lane_id>: <index>,
     *      ...
     *    }
     *  }
     */
    lastAnimatedItemPerLane: any;
    constructor(props?: {
        lanes?: {
            [k: string]: {
                id: string;
                millisecond: number;
            }[];
        } & any;
        comboAttributes?: Record<string, any> | undefined;
        belongingLaneKeysByAnimationId?: Record<string, string[]> | undefined;
        incidentsById?: Record<string, any> | undefined;
    });
    /**
     * This method resizes all the lanes of the Lanes Handler by the durationFraction provided.
     * No checks are performed.
     * This method is been invoked in cases where a full Clip gets resized, so no conflict checks need to
     * run.
     */
    _resize(durationFraction: number): void;
    /**
     * it creates a new LanesHandler that acts as a sanbox for testing changes
     */
    createTestLanesSanbox(): LanesHandler;
    getLane(mcid: any, attr: any): any;
    applySandboxChanges(SanboxObject: any): void;
    laneExists(mcid: string, attr: string, createItIfDoesntExist?: boolean): boolean;
    /**
     * @param {Object} newAnim - an object of the form of a lane item (with keys "millisecond" and "incident"
     * @param {string} mcid
     * @param {String} attr
     * @param {array} excludeIdsFromCheck - optional. If exists it excludes all the ids of this array from check. This
     *  parameter has been added for the edit checks where an animation might overlap another animation that participates on
     *  the move, something that should not happen as the edited animations pre-existed without conflicts and the move of all
     *  of them together guarantees that there is going to be no conflict between them even after the edit
     * @param {Number} testDuration - optional. This parameter is used when the channel needs to addcheck overlaps after duration
     *  edits, so the testDuration is passed (we don't want to pollute the original animation object as it refers to the real one)
     * @returns {array} - a list of all overlapping animations of the lane
     */
    getOverlappingAnims({ millisecond, incident }: {
        millisecond: number;
        incident: any;
    }, mcid: string, attr: string, excludeIdsFromCheck?: any[], testDuration?: number | undefined): any[];
    /**
     * it justs adds the lane item to the lane and adjusts the initial values of the Anims in sequence
     * No checks are performed, just execution.
     * This method is executed on the context of SandboxLanesHandler
     */
    addElementToLane(mcid: string, attr: string, millisecond: number, incident: any): (() => void)[];
    /**
     * it justs updates the lane
     * It gets executed on the context of the real LanesHanlder and not of the Sanbox
     * No checks are performed, just execution
     * @param {array} affectedAnimationsIds
     * @param {number} millisecondDelta
     */
    updateLane(affectedAnimationsIds: string[], millisecondsDelta: number): void;
    /**
     * removes the list of animations as provided
     * @param {array} removedAnimations - an array with the removed animations' ids
     */
    deleteAnimations(removedAnimations: string[]): Record<string, {
        mcid: string;
        attribute: string;
    }>;
    /**
     * This method is responsible for recalculating the scratch values of the first
     * Incident of each of the lanes of the LanesHandler according to the provided
     * context id
     * */
    recalcScratchValues(contextId: any): void;
    getLastAffectedIndex(contextID: string, laneID: string, forceReset?: boolean): any;
    setLastAffectedIndex(contextID: string, laneID: string, index: number): void;
}

declare class AttributeChannel extends Channel {
    static type: string;
    LanesHandler: LanesHandler;
    comboAttributes: string[];
    direction: string;
    fixedAttributeName: string;
    irema: IReMa;
    constructor(props: ConstructorParameters<typeof Channel>[0] & Record<string, string[]>);
    get lanes(): any;
    get incidentsById(): Record<string, any>;
    _resize(durationFraction: Parameters<typeof this$1.LanesHandler._resize>[0]): void;
    /**
     * All of the incidents coming to this method are element-attribute incidents meaning that they only
     * target just one element and also they include just a single attribute on the incident.attrs.animatedAttrs
     * object
     *
     * @param {array} incidents - A collection of Incidents in the form:
     * {
     *  millisecond
     *  incident
     *  id
     * }
     * @param {string} type - can be either "all-or-nothing" (default) or "keep-passing". If type = "all-or-nothing"
     *  the addition passes only if all incidents pass. If type = "keep-passing" the method will still return true
     *  but will also include an errors array on its return and also will only include the success callbacks on
     *  the execute key of its return
     * @returns either:
     *   {
     *       result:true,
     *       execute: // an array of functions that when executed it will add the Incidents on the Channels
     *   }
     *   or
     *   {
     *       result: false,
     *       errors
     *   }
     */
    checkAddition(incidents: any[], type?: string): {
        result: boolean;
        errors: {
            type: string;
            element_mcid: any;
            attribute: any;
            millisecond: any;
            incident: {
                attrs: any;
                props: any;
                duration: any;
            } | undefined;
        }[];
        execute?: undefined;
    } | {
        result: boolean;
        errors: {
            type: string;
            element_mcid: any;
            attribute: any;
            millisecond: any;
            incident: {
                attrs: any;
                props: any;
                duration: any;
            } | undefined;
        }[];
        execute: () => void;
    };
    /**
     * It initially checks if the edit is allowed and if it is it returns an array of executable functions
     * that apply the change
     * @param {array} incidents - the list of the lane items to edit in an array format [object, object, ...]
     * @param {number} millisecondsDelta - the milliseconds delta to apply to the incidents
     * @returns {object} -
     * either:
        {
          result: true,
          execute: // array of functions to be executed in order to apply the edit
        }
      or
        {
          result: false,
          errors: // an array including all the errors / conflicts found on edit
        }
     */
    checkEdit(incidents: any, millisecondsDelta: any): {
        result: false;
        errors: {
            type: string;
            meta: {
                element_mcid: any;
                attribute: any;
                newAnimation: any;
                overlappingAnims: any[];
            };
        }[];
        execute?: undefined;
    } | {
        result: true;
        execute: () => void;
        errors?: undefined;
    };
    /**
     * @param {array} incidents - [{id, start, end, startDelta}]
     * @param {boolean} fullChannelResize - if set to true then the full html channel is resizing. This is a special case as in
     *  that case no checks should be actually perfomed nor the projected candidate should be applied directly
     * */
    checkResizedIncidents(incidents: any, fullChannelResize?: boolean): {
        result: false;
        errors: {
            type: string;
            meta: {
                element_mcid: any;
                attribute: any;
                newAnimation: any;
                overlappingAnims: any[];
            };
        }[];
        execute?: undefined;
    } | {
        execute: () => void;
        result: true;
        errors?: undefined;
    };
    /**
     *
     */
    checkDelete(removedAnimations: any): {
        result: true;
        execute: () => void;
    };
    /**
     * This method is responsible for recalculating the scratch values of the first
     * Incident of each of the lanes of the LanesHandler according to the provided
     * context id
     * */
    recalcScratchValues(contextId: any): void;
    /**
     * Slips to just one lane forwards
     * @param {string} laneid - the id of the lane
     * @param {array} lane - the lane to slip into
     * @param {number} from - the millisecond the slip starts from
     * @param {number} to - the target millisecond of the slip
     * @param {string} contextId - the contextId of the Incidents to slip
     */
    slipIntoLaneForwards(laneid: string, lane: any[], from: number, to: number, contextId: string, forceReset?: boolean): boolean;
    /**
     * Slips to just one lane backwards
     * @param {string} laneid - the id of the lane
     * @param {array} lane - the lane to slip into
     * @param {number} from - the millisecond the slip starts from
     * @param {number} to - the target millisecond of the slip
     * @param {string} contextId - the contextId of the Incidents to slip
     */
    slipToLaneBackwards(laneid: string, lane: any[], from: number, to: number, contextId: string): boolean;
    /**
      @param {number} from - the millisecond to start from
      @param {number} to - the millisecond to go to
      @param {string} contextID - the context id to "move"
      @param {boolean} forceReset - set to true if status recalc is needed after edit
     */
    moveTo(from: number, to: number, contextID: string, forceReset?: boolean): void;
}

declare class DescriptiveIncident extends Leaf {
    constructor(attrs: ConstructorParameters<typeof Leaf>['0'], props: ConstructorParameters<typeof Leaf>['0']);
    static Incident: typeof RealIncidentBase;
    static plugin_npm_name: string;
    static version: string;
    static Channel: typeof AttributeChannel;
    static ClassName: string;
    static attrsValidationRules: null;
    static propsValidationRules: any;
    get duration(): any;
    set duration(milliseconds: any);
    manageEditAttrProps(newAttrs: any, type: keyof this): any;
    detachFromParent(): void;
    handleCheckForInvalidSelectors(): string | {
        id: string | undefined;
        ClassName: any;
        plugin_npm_name: any;
        error: string;
        selector?: undefined;
    } | {
        id: string | undefined;
        ClassName: any;
        plugin_npm_name: any;
        error: string;
        selector: any;
    };
    /**
     * The purpose of this method is to export a portable definition that can be
     * later used in order to rebuild the Inicdent at any time
     */
    exportDefinition(): {
        ClassName: any;
        version: any;
        plugin: any;
        plugin_npm_name: any;
        attrs: any;
        props: any;
    };
    /**
     * The purpose of this method is to export an object with "live" / real reference
     * to the Class of the Incident so it can directly by used for Clip creation
     * */
    exportLiveDefinition(includeId?: boolean): {
        Class: any;
        attrs: any;
        props: any;
    };
}

/**
 * As its name implies, ExtendableClip's one and only use is to extend it in order
 * to create new Clip types. All channel handling, add / edit / remove / resize checks are
 * handled by ExtendableClip itself.
 * ExtendableClip's only need is the this.ownContext property to be defined. All
 * of the class's functionality is based on this object. The expected keys of this object
 * are the following:
 * {
 *  getElements()
 *  getMCID()
 *  setMCID()
 *  getElementSelectorByMCID()
 *  getElementByMCID()
 *  isHostedClip
 *  contextLoaded
 *  unmout()
 * }
 * Clips that extend ExtendableClip need to define this property ("this.ownContext")
 * on their constructor. ExtendableClip itself does NOT define this.ownContext and
 * thus it's not meant to be used alone/directly.
 **/
declare class ExtendableClip extends Group {
    instantiatedChannels: Record<string, Channel>;
    isHostedClip: boolean;
    durationSubs: ((duration: number | string) => void)[];
    clipCopyId?: string;
    ownContext: ExtendableContextHandler['context'];
    iframe: HTMLIFrameElement;
    private _volume;
    constructor(attrs: ConstructorParameters<typeof Group>[0], props: ConstructorParameters<typeof Group>[1], DescriptiveIncident?: DescriptiveIncident);
    get volume(): number | string;
    set volume(volume: number | string);
    get contextReady(): boolean | undefined;
    onClipInitialise(): void;
    /*********************************************************
      Context loading and the contextReady parameter
      *********************************************************
    There are cases that the Clip might need time in order to prepare its context,
    such as asynch sources loading. For this reason we use the contextReady parameter,
    which is set to true by default, and which can change state by the use of the two
    methods: contextLoading and contextLoaded.
    When contextLoading method is executed and the context gets to the loading state
    Incidents might be added to the Clip. While contextReady is set to false the
    onGetContext method of MonoIncidents and ClipCopies will be postponed and run when the context
    is actually loaded
    */
    contextLoading(): void;
    /**
     * This method will be invoked once the context (that is currently loading) has
     * finished loading. In case the Clip is been used as CAsI, ClipCopies might
     * have fired block() so they need to get unblocked. If so, the instantiatedCopiesUnblockingMethods
     * variable will contain the unblocking methods of them and the method will
     * execute them.
     **/
    contextLoaded(): void;
    getElements(selector: string): any[];
    /**
     * This method is been called when a new _ClipCopy enters the real tree successfully.
     * @param {object} contextData - keys: clipId, context
     * */
    addContext(contextData: any): PutMessageOnPipeRes | PutMessageOnPipeRes[];
    exportConstructionArguments(): {
        attrs: any;
        props: any;
    };
    /**
     * completely resizes the Clip without any checks
     */
    _resize(durationFraction: any): void;
    /** *******************************************************
      Editing commands input methods
      ******************************************************** */
    /**
     * This command is proxied form the Clip's parent Descriptor class. The payload
     * is identical to the payload that comes to the Description class:
     * {
     *  incident: the Descriptive Incident to be added
     *  millisecond: the millisecond to add it
     *  targetGroupId: the id of the Group to which we want to the Incident to be placed
     * }
     */
    addIncident(payload: {
        incident: any;
        millisecond: number;
        parentGroupId: string;
    }): {
        result: boolean;
        errors: any;
        execute: () => void;
    } | {
        result: boolean;
        execute: () => void;
    };
    /**
       * The method returns either:
          {
              result:true,
              execute: // an array of functions that when executed it will add the Incidents on the Channels
          }
          or
          {
              result: false,
              errors
          }
      */
    checkAddition(incidentsById: any, type?: string): {
        result: boolean;
        errors: any;
        execute: () => void;
    };
    /**
     * This command comes form the Clip's parent Descriptor class. The payload
     * is identical to the payload that comes to the Description class:
     * {
     *  incident: the Descriptive Incident to be repositioned
     *  millisecond: the new millisecond to put it
     *  targetGroupId: the id of the
     * }
     */
    moveIncident(payload: {
        id: string;
        millisecond: number;
        parentGroupId: string | null;
        positionDelta: number;
    }): {
        result: boolean;
        errors: any;
        execute: () => void;
    } | {
        result: boolean;
        execute: () => void;
    };
    /**
     * The checkEdit method serves exactly what its name implies. To check if the edit of an Incident
     * (edit of Incident's position given in milliseconds delta)
     * is valid and accepted, according to the rules defined on the channels.
     * The method boobles up until it reaches the Clip.
     * @param {object} incidentsById - the incident to edit, provided in an object by id
     * @param {number} millisecondsDelta - the milliseconds delta of the Incident's start time
     The method should return either:
        {
            result:true,
            execute: // an array of functions that when executed it will edit the Incidents on the Channels
        }
        or
        {
            result: false,
            errors
        }
    */
    checkMove(incidentsById: any, millisecondsDelta: any): {
        result: boolean;
        errors: any;
        execute: () => void;
    };
    removeIncident(payload: any): {
        result: boolean;
        errors: any;
        execute: () => void;
    } | {
        result: boolean;
        execute: () => void;
    };
    /**
     * The checkDelete method serves exactly what its name implies. To check if the deletion of some Incidents
     * is valid and accepted, according to the rules defined on the channels.
     * @param {object} incidentsById - the incident to remove in an object, by id
      The result might be either:
        {
            result:true,
            execute: // an array of functions that when executed it will remove the Incident on the Channels
        }
        or
        {
            result: false,
            errors
        }
    */
    checkDelete(incidentsById: any): {
        result: boolean;
        errors: any;
        execute: () => void;
    };
    /**
     * This command is invoked by the Clip's parent Descriptor class. The payload
     * is identical to the payload that comes to the Description class:
     * {
     *  id: the id of the Incident to resize
     *  newSize: the milliseconds of the new duration
     *  fraction: the division of the new duration to the current
     * }
     */
    resizeIncident(payload: any): {
        result: boolean;
        errors: any;
        execute: () => void;
    } | {
        result: boolean;
        execute: () => void;
    };
    /**
     * checks if a duration edit is feasible and doesn't cause conflicts
     * @param {number} durationFraction - the duration fraction
     * @param {object} incidentsById - the Incidents to resize
     * @param {number} adjustMillisecond - a time adjustment very useful on repulsiveness
     * */
    checkResize(durationFraction: number, incidentsById: any, adjustMillisecond?: number): {
        result: boolean;
        errors: any;
        execute: () => void;
    };
    get context(): Context;
    /**
     * Returns an object with keys the keys of all the plugins Incidents of which appear in the
     * tree of the Group. All Incidents are projected to the Group's timeline.
     * The array includes the Group's projection too
     */
    getIncidentsByChannel(adjustMillisecond?: number): {
        "@donkeyclip/self-contained-incidents": {
            millisecond: number;
            incident: ExtendableClip;
            id: string | undefined;
            parentMillisecond: undefined;
        }[];
    };
    /**
     * Eventual Clips have their own context, still they might belong to another Clip's
     * tree (CASI). In such a case this method gives the opportunity to set things up
     * and do operations related with their parent's context (such as subscribing to audio effect nodes)
     * */
    _onGetContextOnce(_parentClipContext: any): void;
    handleRecalcDuration(_target: any, payload: any): boolean;
    /**
     * @param {number} fraction - a number from 0 to 1 representing the fraction of duration covered
     * @param {number} milliseconds - the number of milliseconds passed from start of the incident
     * @param {string} contextId - defaults to the id of the realClip itself. Don't forget that a realClip
     *      might belong to a selector Clip (so it's a Fragmented Clip), with many "real" ClipCopies. All ClipCopies hold
     *      a reference to this Clip via their "realClip" property. Whenever any
     *      of these ClipCopies progresses (via the onProgress method) calls
     *      the "onProgress" of the realClip, passing their id so the ContextAwareIncidents
     *      that will also progress via the Channels know which specific Incident to progress.
     *      That's the result of keeping just one real tree, belonging always to the realClip
     *      (either Fragmented or Hosted) ending to ContextAwareIncident leafs that
     *      are the ones to hold the ClipCopies instances.
     * @param {boolean} forceReset - set to true in cases we want full flash of the state
     */
    onProgress(fraction: number, milliseconds: number, contextId?: string, forceReset?: boolean): void;
    flash(): void;
    subscribeToDurationChange(method: any): void;
    /** ***************************************************** */
    /** ****** BLOCKING WAITINGS SET / REMOVE ************** */
    handleSetBlockingWaiting(target: any, payload: any): void;
    handleRemoveBlockingWaiting(target: any, payload: any): void;
    setCustomEntity(id: any, entity: any, classes?: never[]): boolean;
    exportLiveDefinition(_includeID?: boolean | undefined): Definition;
    manageEditAttrProps(_newAttr: any, _type: keyof this): CheckResult;
}

declare class RealIncidentBase {
    DescriptiveIncident: DescriptiveIncident;
    blockID: string | undefined;
    mc_plugin_npm_name: string;
    id?: string;
    getIncidentsByChannel(adjustMillisecond?: number, parentMillisecond?: number | null | undefined): {
        [x: string]: {
            millisecond: number;
            parentMillisecond: number | null | undefined;
            incident: MonoIncident | ExtendableClip | Group;
            id: string | undefined;
        }[];
    };
    /**
     *
     * @param {string} description: the description of the block (human readable)
     * @param {object} options: an (optional) set of options for the block. For the time being the only supported option
     * is "exceptional" (boolean) value which if it's true the incident that set the block must be excluded from the block
     * This is called "exceptional block" and we use it in cases an incident that blocks need to remain at the playing
     * state in order to keep on trying to get unblocked (e.g. a youtube video play), otherwise we will end up with the
     * "waiting deadlock" where the clip waits for the incident to get unblocked while the incident waits for the clip play
     * so it can keep on trying to do so. In such cases "exceptional" should be true
     */
    setBlock(description?: string, options?: {
        blockId?: string | undefined;
    }): void;
    unblock(blockId?: string | null): void;
}

declare class MonoIncident extends RealIncidentBase {
    attributeKey: string | number | undefined;
    attrs: {
        animatedAttrs: Record<string, any>;
        initialValues?: Record<string, any>;
    };
    autoGenerated: boolean;
    context: Record<string, any>;
    dna: {
        mcid: string;
        context: any;
    } | undefined;
    gotContext: boolean;
    hasIncidents: boolean;
    initialValues: Record<string, any>;
    mcid: string | undefined;
    modelId: string | undefined;
    plugin_channel_class: string | typeof Channel | undefined;
    props: {
        selector: string;
        duration: number;
        id?: string | undefined;
        modelId?: string | undefined;
        plugin_channel_class?: string | undefined;
        mc_plugin_npm_name?: string | undefined;
    };
    pureInitialValues: null;
    userDefinedInitialValues: Record<string, any>;
    runTimeInfo: {
        currentMillisecond: number;
    };
    constructor(attrs?: MonoIncident['attrs'], props?: {
        selector: string;
        duration: number;
        id?: string;
        modelId?: string;
        plugin_channel_class?: string;
        mc_plugin_npm_name?: string;
    }, dna?: {
        mcid: string;
        context: any;
    });
    get duration(): number;
    set duration(_duration: number);
    get selector(): string;
    get animAttributes(): Record<string, any>;
    set animAttributes(value: Record<string, any>);
    /**
      This method should be overwritten by the Incidents of the plugins. The method returns
      the initial value that the element of it has as the library calculates / defines them. The
      returned value represents the very initial value of the element's attribute before
      any Incident that alters it gets added.
  
      @returns {mixed} - the initial value of the element's attribute just when the HTML & CSS
      of the Clip gets rendered
      */
    getScratchValue(): number;
    get element(): any;
    get targetValue(): any;
    getElementAttribute(attr: any): any;
    getFraction(ms: any): number;
    hasUserDefinedInitialValue(): boolean;
    setInitialValue(value: any, storePure?: boolean): void;
    get initialValue(): any;
    _onGetContextOnce(_ctx: any): void;
    onGetContext(): void;
    lastWish(): void;
    onInitialise(): void;
    /**
     * Method called on progress of the timed incident.
     * @param {number} fraction - a number from 0 to 1 representing the fraction of duration covered
     * @param {number} milliseconds - the number of milliseconds passed from start of the incident
     */
    onProgress(_fraction: number, _milliseconds: number, _contextID: string, forceReset?: boolean): void;
}

declare class ClipChannel extends Channel {
    incidents: {
        id: string;
        millisecond: number;
    }[];
    incidentsById: Record<string, MonoIncident>;
    onInitialise(): void;
    _incidentById(id: string): MonoIncident;
    _resize(durationFraction: any): void;
    /**
      * @param {array} incidents - a collection of all incidents to be added on the form:
      *
          {
              id
              millisecond
              incident
          }
      * @returns {object} -
      * either:
          {
              result:true,
              execute: // a function that when executed it will add the Incidents on the Channels
          }
          or
          {
              result: false,
              errors
          }
      */
    checkAddition(incidents: Parameters<Channel['checkAddition']>['0']): ReturnType<Channel['checkAddition']>;
    /**
      @param {array} incidentsArray - A collection of the Incidetns to get edited in the form:
      {
          id
          millisecond
          incident
      }
      @param {number} millisecondsDelta- the delta of the star point of the provided incidents
      */
    checkEdit(incidentsArray: any, millisecondsDelta: any): {
        result: true;
        execute: () => void;
    };
    checkDelete(incidentsArray: any): {
        result: true;
        execute: () => void;
    };
    /**
     * @param {array} incidents - [{id, start, end, startDelta}]
     */
    checkResizedIncidents(incidents: any): {
        result: true;
        execute: () => void;
    };
    /**
       @param {number} from - the millisecond to start from
       @param {number} to - the millisecond to go to
       @param {string} contextID - the context id to move
       @param {boolean} forceReset - set to true when we want full flash
       */
    moveTo(from: any, to: any, contextID: any, forceReset?: boolean): void;
}

declare class DescriptiveAudioClip extends HTMLDescriptiveClip {
    constructor(attrs: ConstructorParameters<typeof HTMLDescriptiveClip>['0'], props?: ConstructorParameters<typeof HTMLDescriptiveClip>['1']);
}

declare const CSSLayer: Omit<{
    [x: string]: {
        new (attrs: unknown, props: unknown): {};
        targetClass: any;
    };
}, "Clip"> & {
    Clip: {
        new (attrs: LeafProps & ClipProps, props?: (LeafProps & ClipProps) | null | undefined): {
            mustHaveNullClip?: boolean | undefined;
            initParams: InitParams | undefined;
            volumeChangeSubsribers: Record<string, (arg: number) => void>;
            audio?: string | undefined;
            audioClip: AudioClip | NullClip;
            statusBeforeBlock?: StateStatus | undefined;
            nonBlockingErrorClip?: boolean | undefined;
            readonly selectorToPassToChildren: null;
            inheritedSelector: any;
            readonly html: string;
            readonly css: string;
            readonly fonts: never[];
            readonly audioSources: never[];
            resolveAudioSources(audioSources: any): any;
            detachFromParent(): void;
            duration: number;
            systoleDiastole(durationFraction: any): void;
            exportLiveDefinition(includeId?: boolean): Definition;
            _buildTree(): void;
            resize(newSize: number): {
                result: boolean;
            } | {
                result: boolean;
                reason: string;
            };
            manageEditAttrProps(newAttrs: any, type: any): {
                result: boolean;
                errors: string[];
            };
            handleCheckForClip(_target: any, _payload: any): boolean;
            handleGetElements(target: any, payload: any): any;
            handleCheckAddition(target: any, payload: any): any;
            handleCheckMove(_target: any, payload: any): any;
            handleCheckDeletion(_target: any, payload: any): any;
            handleCheckResize(_target: any, payload: any): any;
            handleFlash(_target: any, payload: any): string | void;
            exportDefinition(): {
                ClassName: any;
                version: any;
                plugin: any;
                plugin_npm_name: any;
                attrs: any;
                props: any;
                incidents: Record<string, {
                    id: string;
                    position: any;
                    leaf: any;
                }>;
                duration: any;
            };
            handleSetBlock(_target: any, payload: BlockPayload): string | undefined;
            handleUnBlock(target: any, payload: any): string | undefined;
            stop(): void;
            onProgress(fraction: number, millisecond: number): void;
            paste(host: any): ClipClone | null;
            flash(): void;
            readonly volume: number;
            setVolume(vol: number): {
                result: boolean;
                errors: {
                    type: string;
                }[];
            } | {
                result: boolean;
                errors?: undefined;
            };
            attachMediaElementSource(source: HTMLMediaElement): void;
            volumeChangeSubscribe(id: string, funct: () => void): any;
            volumeChangeUnsubscribe(id: string): number;
            handleVolumeChangeSubscribe(_target: any, payload: {
                type: any;
                id: string | number;
                funct: any;
            }): string | number | false;
            isTheRootClip?: boolean | undefined;
            listeners: Record<string, {
                funct: (ms: number, newState: any, options?: any) => void;
                onlyOnStateChange?: boolean | undefined;
                threshold: number;
                cavaDelta: number;
                roundTo: number;
            }>;
            previousTimeStamp: number;
            speed: number;
            pauseMoment: number;
            _setState(newState: StateStatus, options?: {}): void;
            handleSetState(_target: any, payload: {
                newState: StateStatus;
                options?: any;
            }): void;
            play(debug?: boolean): void;
            pause(): void;
            arm(): void;
            complete(): void;
            block(options?: {
                exception?: any;
            }): void;
            onPlay(): void;
            onWait(): void;
            playableProgress(fraction: number, millisecond: number): boolean;
            executionSpeed: string | number;
            step(timestamp: number, debug?: boolean): void;
            subscribe(id: string, funct: (ms: number, state: string, options: any) => void, threshold: number, roundTo: number, onlyOnStateChange?: boolean): void;
            unsubscribe(id: any): void;
            subscribeToDurationChange(funct: any): boolean;
            passiveAddition?: boolean | undefined;
            _calculateDuration(forceGroups?: any): boolean;
            _rebuildTree(): void;
            buildTree(): void;
            addIncident(descriptiveIncident: any, position?: any, options?: {
                check: boolean;
            }): any;
            moveIncident(input: any, position: any): any;
            removeIncident(input: any): any;
            handleSetDurationDynamic(target: any, payload: any): void;
            calculatedDuration: number;
            runTimeInfo: {
                currentMillisecond: number;
                state?: StateStatus | undefined;
            };
            resetDuration(): void;
            handleRecalcDuration(target: any, payload: any): boolean | PutMessageOnPipeRes | PutMessageOnPipeRes[];
            getLeafById(id: string, onlyDirectChild?: boolean): Leaf | null;
            getLeafPosition(id: string | number): any;
            handleGetLeafPosition(target: any, payload: {
                id: string;
            }): any;
            checkAddition(leaf: any, position: any): {
                result: boolean;
                reason: string;
            } | {
                result: boolean;
                reason?: undefined;
            };
            addChild(leaf: any, position: any): {
                result: boolean;
            } | {
                result: boolean;
                reason: string;
            };
            checkRemoveChild(id: any): {
                result: boolean;
                reason: string;
            } | {
                result: boolean;
                reason?: undefined;
            };
            removeChild(id: any): {
                result: boolean;
            };
            checkEditPosition(id: any, position: any): {
                result: boolean;
                reason: string;
            } | {
                result: boolean;
                reason?: undefined;
            };
            editPosition(id: any, position: any, bypassRecalcDuration?: boolean): {
                result: boolean;
            } | undefined;
            putMessageOnPipe(name: PutMessageOnPipeNames, payload: Record<string, unknown>, target: string | Record<string, any> | null, options?: {
                selfExecute?: boolean | undefined;
                direction?: _DIRECTIONS | undefined;
                positionDelta?: number | undefined;
            }): PutMessageOnPipeRes | PutMessageOnPipeRes[];
            putMsgOnPipeWithResult(name: PutMessageOnPipeNames, payload: Record<string, unknown>, target: string | Record<string, any> | null, options?: {
                selfExecute?: boolean | undefined;
                direction?: _DIRECTIONS | undefined;
                positionDelta?: number | undefined;
            } | undefined): {
                result: boolean;
            };
            handleGetPositionOnPyramidion(target: any, payload: {
                id: string;
                delta: number;
            }): string | number | boolean | {
                result: boolean;
            } | undefined;
            constructionIngredients: ConstructionIngredients;
            mcid: string;
            easing: (fraction: number) => number;
            plugin_channel_class: typeof Channel;
            attributesStaggers: any;
            propsStaggers: any;
            dynamicDurationValue: any;
            blockingWaitings: Record<string, BlockPayload>;
            _duration?: number | undefined;
            realClip: any;
            originalContextKey?: string | number | undefined;
            contexts: Record<string, Context>;
            attrs: any;
            _inheritedSelector: string | null;
            isNode: boolean;
            passive?: boolean | undefined;
            parentNode: any;
            props: any;
            children: Record<string | number, {
                id: string;
                position: number;
                leaf: any;
            }>;
            name: string;
            delay: number;
            hiatus: number;
            repeats: number;
            setNewDuration(newDuration: number): void;
            readonly hasParent: boolean;
            attachToNode(node: any): void;
            bypass(): string;
            readonly positionOnPyramidion: string | number | boolean | {
                result: boolean;
            } | undefined;
            getPositionOnPyramidion(delta?: number): string | number | boolean | {
                result: boolean;
            } | undefined;
            editAttributes(newAttrs: any): {
                result: true;
                execute?: (() => void) | undefined;
            } | {
                result: boolean;
                errors: any;
            } | {
                result: boolean;
                errors?: undefined;
            };
            editProperties(newProps: any): {
                result: boolean;
                errors?: undefined;
            } | {
                result: boolean;
                errors: any;
            } | {
                result: true;
                execute?: (() => void) | undefined;
            };
            clone(attrs?: {}, props?: {}): HTMLDescriptiveClip | CheckResult;
            selector(): any;
            getElements(_selector: string): string | boolean | any[] | {
                result: boolean;
            } | undefined;
            setupDynamicValues(): {
                attrs: {
                    expression?: any;
                    initParams?: InitParams | undefined;
                };
                props: {
                    expression?: any;
                    initParams?: InitParams | undefined;
                };
            };
            DescriptiveIncident: DescriptiveIncident;
            blockID: string | undefined;
            mc_plugin_npm_name: string;
            id?: string | undefined;
            getIncidentsByChannel(adjustMillisecond?: number, parentMillisecond?: number | null | undefined): {
                [x: string]: {
                    millisecond: number;
                    parentMillisecond: number | null | undefined;
                    incident: MonoIncident | ExtendableClip | Group;
                    id: string | undefined;
                }[];
            };
            setBlock(description?: string | undefined, options?: {
                blockId?: string | undefined;
            }): void;
            unblock(blockId?: string | null): void;
        };
        Incident: any;
        version: string;
        plugin: string;
        audio: AUDIO_OPTIONS;
        customClip: boolean;
        isClip: boolean;
        plugin_npm_name: string;
        Channel: typeof ClipChannel;
        ClassName: string;
        propsValidationRules: any;
        isGroup: boolean;
        attrsValidationRules: null;
    } | {
        new (_attrs: any, _props: any): {};
    } | undefined;
};
declare function setCore(Effect: CSSEffect): void;
declare class CSSEffect {
    static targetClass: any;
    constructor(attrs: ConstructorParameters<(typeof CSSLayer)['CSSEffect']>['0'] & {
        animatedAttrs: Record<'transform', Record<keyof typeof transform, any>> | Record<string, any>;
        initialValues?: Record<string, any>;
    }, props: ConstructorParameters<(typeof CSSLayer)['CSSEffect']>['1'] & {
        duration: number | string;
        selector: string;
        delay?: number | string;
        repeats?: number;
        hiatus?: number | string;
        id?: string;
        name?: string;
        easing?: string;
    });
}

declare class ExtendableCSSEffect extends MonoIncident {
    attributeKey: Exclude<keyof InstanceType<typeof globalThis.CSSStyleDeclaration>, symbol>;
    compoAttributes: {
        transform: readonly ["translateX", "translateY", "translateZ", "rotate", "rotateX", "rotateY", "rotateZ", "scale", "scaleX", "scaleY", "scaleZ", "skewX", "skewY"];
    };
    constructor(attrs?: {
        animatedAttrs: Record<string, any>;
        initialValues?: Record<string, any> | undefined;
    } | undefined, props?: {
        selector: string;
        duration: number;
        id?: string | undefined;
        modelId?: string | undefined;
        plugin_channel_class?: string | undefined;
        mc_plugin_npm_name?: string | undefined;
    } | undefined, dna?: ConstructorParameters<typeof MonoIncident>[2]);
    getScratchValue(): any;
}

declare function alwaysReturnFalseWithResults(_args?: any, _arg?: any): {
    result: boolean;
};

declare function handleInvalidIncidentChange(): {
    result: boolean;
    errors: string[];
};
declare class DescriptiveCombo extends DescriptiveGroup {
    static ClassName: string;
    static attrsValidationRules: null;
    static propsValidationRules: any;
    static isCombo: boolean;
    constructor(attrs: any, props: any);
    get incidents(): null;
    get duration(): any;
    set duration(ms: any);
    /**************** OVERWRITE DESCRIPTIVE GROUP'S INCIDENT MANAGEMENT METHODS ********
     * A DescriptiveCombo is a Group itself that hosts other Incidents. Combos though
     * define solid and specific behaviors, "hardcoded" right from
     * Combo's creation. For this, no direct handling of its Incidents is allowed from the
     * outside (and neither from the inside after the first build).
     * Thus we overwrite the Incidents management layer so it prevents it
     * ********************************************************************************/
    addIncident: typeof handleInvalidIncidentChange;
    moveIncident: typeof handleInvalidIncidentChange;
    removeIncident: typeof handleInvalidIncidentChange;
    /** ***************** HANDLING METHODS OVERWRITE *********************** */
    handleCheckAddition: typeof alwaysReturnFalseWithResults;
    handleCheckMove: typeof alwaysReturnFalseWithResults;
    handleCheckDeletion: typeof alwaysReturnFalseWithResults;
    handleCheckResize: typeof alwaysReturnFalseWithResults;
    /**
     * The purpose of this method is to export a portable definition that can be
     * later used in order to rebuild the Incident at any time
     */
    exportDefinition(): {
        ClassName: any;
        version: any;
        plugin: any;
        plugin_npm_name: any;
        attrs: any;
        props: any;
        incidents: {};
        duration: any;
    };
    /**
     * The purpose of this method is to export an object with "live" / real reference
     * to the Class of the Incident so it can directly by used for Clip creation
     * */
    exportLiveDefinition(includeId?: boolean): {
        Class: any;
        attrs: any;
        props: any;
        incidents: {};
    };
}

declare class MediaPlay extends RealIncidentBase {
    attrs: {};
    autoGenerated: boolean;
    context: any;
    dna: {
        context: any;
        mcid: string;
    };
    gotContext: boolean;
    hasIncidents: boolean;
    mcid: string;
    modelId: string | undefined;
    plugin_channel_class: any;
    props: {
        id?: string | undefined;
        modelId?: string | undefined;
        plugin_channel_class?: any;
        mc_plugin_npm_name?: string | undefined;
        selector?: string | undefined;
    };
    constructor(attrs: {} | undefined, props: {
        id?: string | undefined;
        modelId?: string | undefined;
        plugin_channel_class?: any;
        mc_plugin_npm_name?: string | undefined;
        selector?: string | undefined;
    } | undefined, dna: {
        context: any;
        mcid: string;
    });
    get selector(): string | undefined;
    get element(): any;
    _onGetContextOnce(): void;
    onGetContext(): void;
    lastWish(): void;
    onInitialise(_attrs: typeof this.attrs, _props: typeof this.props): void;
    /**
     * Method called on progress of the timed incident.
     * @param {number} milliseconds - the number of milliseconds passed from start of the incident
     */
    onProgress(_milliseconds: number): void;
    /**
     * starts the execution of the media from the specified millisecond
     * */
    play(_millisecond: number): boolean;
    /**
     * stops the execution of the media
     * */
    stop(): void;
}

var version = "9.17.1";

/**
 * Effect class takes on constructor:
 * attrs:
 *  - animatedAttrs: valid animated attributes are "gain", "pan"
 *  -
 * */
declare class Effect extends MonoIncident {
    onProgress(ms: number): boolean;
    getScratchValue(): any;
}

type ClipDefinition = {
  exportable:
    | typeof AudioClip
    | typeof ExtendableClip
    | typeof BrowserClip
    | typeof AudioClip;
  attributesValidationRules?: Record<string, string | ValidationSchema>;
};
interface IncidentDefinition extends Omit<ClipDefinition, 'exportable'> {
  readonly name: string;
  exportable: typeof ExtendableCSSEffect | typeof Effect | typeof MediaPlay;
  originalDims?: {
    width: string;
    height: string;
  };
}
type Plugin = {
  npm_name: string;
  readonly name?: string;
  incidents?: IncidentDefinition[];
  audio?: AUDIO_OPTIONS;
  default?: Plugin;
  readonly version?: string;
  Clip?: ClipDefinition;
  compositeAttributes?: {
    [key: string]: string[];
  };
};

declare function loadPlugin<T extends Plugin>(plugin: T): Omit<{
    [x: string]: {
        new (attrs: unknown, props: unknown): {};
        targetClass: any;
    };
}, "Clip"> & {
    Clip: {
        new (attrs: LeafProps & ClipProps, props?: (LeafProps & ClipProps) | null | undefined): {
            mustHaveNullClip?: boolean | undefined;
            initParams: InitParams | undefined;
            volumeChangeSubsribers: Record<string, (arg: number) => void>;
            audio?: string | undefined;
            audioClip: AudioClip | NullClip;
            statusBeforeBlock?: StateStatus | undefined;
            nonBlockingErrorClip?: boolean | undefined;
            readonly selectorToPassToChildren: null;
            inheritedSelector: any;
            readonly html: string;
            readonly css: string;
            readonly fonts: never[];
            readonly audioSources: never[];
            resolveAudioSources(audioSources: any): any;
            detachFromParent(): void;
            duration: number;
            systoleDiastole(durationFraction: any): void;
            exportLiveDefinition(includeId?: boolean): Definition;
            _buildTree(): void;
            resize(newSize: number): {
                result: boolean;
            } | {
                result: boolean;
                reason: string;
            };
            manageEditAttrProps(newAttrs: any, type: any): {
                result: boolean;
                errors: string[];
            };
            handleCheckForClip(_target: any, _payload: any): boolean;
            handleGetElements(target: any, payload: any): any;
            handleCheckAddition(target: any, payload: any): any;
            handleCheckMove(_target: any, payload: any): any;
            handleCheckDeletion(_target: any, payload: any): any;
            handleCheckResize(_target: any, payload: any): any;
            handleFlash(_target: any, payload: any): string | void;
            exportDefinition(): {
                ClassName: any;
                version: any;
                plugin: any;
                plugin_npm_name: any;
                attrs: any;
                props: any;
                incidents: Record<string, {
                    id: string;
                    position: any;
                    leaf: any;
                }>;
                duration: any;
            };
            handleSetBlock(_target: any, payload: BlockPayload): string | undefined;
            handleUnBlock(target: any, payload: any): string | undefined;
            stop(): void;
            onProgress(fraction: number, millisecond: number): void;
            paste(host: any): ClipClone | null;
            flash(): void;
            readonly volume: number;
            setVolume(vol: number): {
                result: boolean;
                errors: {
                    type: string;
                }[];
            } | {
                result: boolean;
                errors?: undefined;
            };
            attachMediaElementSource(source: HTMLMediaElement): void;
            volumeChangeSubscribe(id: string, funct: () => void): any;
            volumeChangeUnsubscribe(id: string): number;
            handleVolumeChangeSubscribe(_target: any, payload: {
                type: any;
                id: string | number;
                funct: any;
            }): string | number | false;
            isTheRootClip?: boolean | undefined;
            listeners: Record<string, {
                funct: (ms: number, newState: any, options?: any) => void;
                onlyOnStateChange?: boolean | undefined;
                threshold: number;
                cavaDelta: number;
                roundTo: number;
            }>;
            previousTimeStamp: number;
            speed: number;
            pauseMoment: number;
            _setState(newState: StateStatus, options?: {}): void;
            handleSetState(_target: any, payload: {
                newState: StateStatus;
                options?: any;
            }): void;
            play(debug?: boolean): void;
            pause(): void;
            arm(): void;
            complete(): void;
            block(options?: {
                exception?: any;
            }): void;
            onPlay(): void;
            onWait(): void;
            playableProgress(fraction: number, millisecond: number): boolean;
            executionSpeed: string | number;
            step(timestamp: number, debug?: boolean): void;
            subscribe(id: string, funct: (ms: number, state: string, options: any) => void, threshold: number, roundTo: number, onlyOnStateChange?: boolean): void;
            unsubscribe(id: any): void;
            subscribeToDurationChange(funct: any): boolean;
            passiveAddition?: boolean | undefined;
            _calculateDuration(forceGroups?: any): boolean;
            _rebuildTree(): void;
            buildTree(): void;
            addIncident(descriptiveIncident: any, position?: any, options?: {
                check: boolean;
            }): any;
            moveIncident(input: any, position: any): any;
            removeIncident(input: any): any;
            handleSetDurationDynamic(target: any, payload: any): void;
            calculatedDuration: number;
            runTimeInfo: {
                currentMillisecond: number;
                state?: StateStatus | undefined;
            };
            resetDuration(): void;
            handleRecalcDuration(target: any, payload: any): boolean | PutMessageOnPipeRes | PutMessageOnPipeRes[];
            getLeafById(id: string, onlyDirectChild?: boolean): Leaf | null;
            getLeafPosition(id: string | number): any;
            handleGetLeafPosition(target: any, payload: {
                id: string;
            }): any;
            checkAddition(leaf: any, position: any): {
                result: boolean;
                reason: string;
            } | {
                result: boolean;
                reason?: undefined;
            };
            addChild(leaf: any, position: any): {
                result: boolean;
            } | {
                result: boolean;
                reason: string;
            };
            checkRemoveChild(id: any): {
                result: boolean;
                reason: string;
            } | {
                result: boolean;
                reason?: undefined;
            };
            removeChild(id: any): {
                result: boolean;
            };
            checkEditPosition(id: any, position: any): {
                result: boolean;
                reason: string;
            } | {
                result: boolean;
                reason?: undefined;
            };
            editPosition(id: any, position: any, bypassRecalcDuration?: boolean): {
                result: boolean;
            } | undefined;
            putMessageOnPipe(name: PutMessageOnPipeNames, payload: Record<string, unknown>, target: string | Record<string, any> | null, options?: {
                selfExecute?: boolean | undefined;
                direction?: _DIRECTIONS | undefined;
                positionDelta?: number | undefined;
            }): PutMessageOnPipeRes | PutMessageOnPipeRes[];
            putMsgOnPipeWithResult(name: PutMessageOnPipeNames, payload: Record<string, unknown>, target: string | Record<string, any> | null, options?: {
                selfExecute?: boolean | undefined;
                direction?: _DIRECTIONS | undefined;
                positionDelta?: number | undefined;
            } | undefined): {
                result: boolean;
            };
            handleGetPositionOnPyramidion(target: any, payload: {
                id: string;
                delta: number;
            }): string | number | boolean | {
                result: boolean;
            } | undefined;
            constructionIngredients: ConstructionIngredients;
            mcid: string;
            easing: (fraction: number) => number;
            plugin_channel_class: typeof Channel;
            attributesStaggers: any;
            propsStaggers: any;
            dynamicDurationValue: any;
            blockingWaitings: Record<string, BlockPayload>;
            _duration?: number | undefined;
            realClip: any;
            originalContextKey?: string | number | undefined;
            contexts: Record<string, Context>;
            attrs: any;
            _inheritedSelector: string | null;
            isNode: boolean;
            passive?: boolean | undefined;
            parentNode: any;
            props: any;
            children: Record<string | number, {
                id: string;
                position: number;
                leaf: any;
            }>;
            name: string;
            delay: number;
            hiatus: number;
            repeats: number;
            setNewDuration(newDuration: number): void;
            readonly hasParent: boolean;
            attachToNode(node: any): void;
            bypass(): string;
            readonly positionOnPyramidion: string | number | boolean | {
                result: boolean;
            } | undefined;
            getPositionOnPyramidion(delta?: number): string | number | boolean | {
                result: boolean;
            } | undefined;
            editAttributes(newAttrs: any): {
                result: true;
                execute?: (() => void) | undefined;
            } | {
                result: boolean;
                errors: any;
            } | {
                result: boolean;
                errors?: undefined;
            };
            editProperties(newProps: any): {
                result: boolean;
                errors?: undefined;
            } | {
                result: boolean;
                errors: any;
            } | {
                result: true;
                execute?: (() => void) | undefined;
            };
            clone(attrs?: {}, props?: {}): HTMLDescriptiveClip | CheckResult;
            selector(): any;
            getElements(_selector: string): string | boolean | any[] | {
                result: boolean;
            } | undefined;
            setupDynamicValues(): {
                attrs: {
                    expression?: any;
                    initParams?: InitParams | undefined;
                };
                props: {
                    expression?: any;
                    initParams?: InitParams | undefined;
                };
            };
            DescriptiveIncident: DescriptiveIncident;
            blockID: string | undefined;
            mc_plugin_npm_name: string;
            id?: string | undefined;
            getIncidentsByChannel(adjustMillisecond?: number, parentMillisecond?: number | null | undefined): {
                [x: string]: {
                    millisecond: number;
                    parentMillisecond: number | null | undefined;
                    incident: MonoIncident | ExtendableClip | Group;
                    id: string | undefined;
                }[];
            };
            setBlock(description?: string | undefined, options?: {
                blockId?: string | undefined;
            }): void;
            unblock(blockId?: string | null): void;
        };
        Incident: any;
        version: string;
        plugin: string;
        audio: AUDIO_OPTIONS;
        customClip: boolean;
        isClip: boolean;
        plugin_npm_name: string;
        Channel: typeof ClipChannel;
        ClassName: string;
        propsValidationRules: any;
        isGroup: boolean;
        attrsValidationRules: null;
    } | {
        new (_attrs: any, _props: any): {};
    } | undefined;
};

declare class TimeCapsule {
    memory: any;
    constructor();
    startJourney(incident: any): false | {
        station(millisecond: number): void;
        exportLog(): {
            startMillisecond: number;
            startState: StateStatus;
            stations: number[];
        };
        destination(millisecond?: number | undefined): void;
    };
}

declare const JSX: (tag: any, props: any, ...children: any[]) => any;
declare const utils: {
    easings: {
        readonly linear: (fraction: any) => any;
        readonly easeInQuad: (fraction: any) => number;
        readonly easeOutQuad: (fraction: any) => number;
        readonly easeInOutQuad: (fraction: any) => number;
        readonly easeInCubic: (fraction: any) => number;
        readonly easeOutCubic: (fraction: any) => number;
        readonly easeInOutCubic: (fraction: any) => number;
        readonly easeInQuart: (fraction: any) => number;
        readonly easeOutQuart: (fraction: any) => number;
        readonly easeInOutQuart: (fraction: any) => number;
        readonly easeInQuint: (fraction: any) => number;
        readonly easeOutQuint: (fraction: any) => number;
        readonly easeInOutQuint: (fraction: any) => number;
        readonly easeInSine: (fraction: any) => number;
        readonly easeOutSine: (fraction: any) => number;
        readonly easeInOutSine: (fraction: any) => number;
        readonly easeInExpo: (fraction: any) => number;
        readonly easeOutExpo: (fraction: any) => number;
        readonly easeInOutExpo: (fraction: any) => any;
        readonly easeInCirc: (fraction: any) => any;
        readonly easeOutCirc: (fraction: any) => number;
        readonly easeInOutCirc: (fraction: any) => number;
        readonly easeInElastic: (fraction: any) => any;
        readonly easeOutElastic: (fraction: any) => any;
        readonly easeInOutElastic: (fraction: any) => any;
        readonly easeInBack: (fraction: any) => number;
        readonly easeOutBack: (fraction: any) => number;
        readonly easeInOutBack: (fraction: any) => number;
        readonly easeInBounce: (fraction: any) => number;
        readonly easeOutBounce: (fraction: any) => number;
        readonly easeInOutBounce: (fraction: any) => number;
    };
    clipFromDefinition: typeof constructIncident;
};
declare const AudioEffect: {
    new (attrs: unknown, props: unknown): {};
    targetClass: any;
};
declare const AudioPlayback: {
    new (attrs: unknown, props: unknown): {};
    targetClass: any;
};
declare const CoreAudioClip: {
    new (attrs: LeafProps & ClipProps, props?: (LeafProps & ClipProps) | null | undefined): {
        mustHaveNullClip?: boolean | undefined;
        initParams: InitParams | undefined;
        volumeChangeSubsribers: Record<string, (arg: number) => void>;
        audio?: string | undefined;
        audioClip: AudioClip | NullClip;
        statusBeforeBlock?: StateStatus | undefined;
        nonBlockingErrorClip?: boolean | undefined;
        readonly selectorToPassToChildren: null;
        inheritedSelector: any;
        readonly html: string;
        readonly css: string;
        readonly fonts: never[];
        readonly audioSources: never[];
        resolveAudioSources(audioSources: any): any;
        detachFromParent(): void;
        duration: number;
        systoleDiastole(durationFraction: any): void;
        exportLiveDefinition(includeId?: boolean): Definition;
        _buildTree(): void;
        resize(newSize: number): {
            result: boolean;
        } | {
            result: boolean;
            reason: string;
        };
        manageEditAttrProps(newAttrs: any, type: any): {
            result: boolean;
            errors: string[];
        };
        handleCheckForClip(_target: any, _payload: any): boolean;
        handleGetElements(target: any, payload: any): any;
        handleCheckAddition(target: any, payload: any): any;
        handleCheckMove(_target: any, payload: any): any;
        handleCheckDeletion(_target: any, payload: any): any;
        handleCheckResize(_target: any, payload: any): any;
        handleFlash(_target: any, payload: any): string | void;
        exportDefinition(): {
            ClassName: any;
            version: any;
            plugin: any;
            plugin_npm_name: any;
            attrs: any;
            props: any;
            incidents: Record<string, {
                id: string;
                position: any;
                leaf: any;
            }>;
            duration: any;
        };
        handleSetBlock(_target: any, payload: BlockPayload): string | undefined;
        handleUnBlock(target: any, payload: any): string | undefined;
        stop(): void;
        onProgress(fraction: number, millisecond: number): void;
        paste(host: any): ClipClone | null;
        flash(): void;
        readonly volume: number;
        setVolume(vol: number): {
            result: boolean;
            errors: {
                type: string;
            }[];
        } | {
            result: boolean;
            errors?: undefined;
        };
        attachMediaElementSource(source: HTMLMediaElement): void;
        volumeChangeSubscribe(id: string, funct: () => void): any;
        volumeChangeUnsubscribe(id: string): number;
        handleVolumeChangeSubscribe(_target: any, payload: {
            type: any;
            id: string | number;
            funct: any;
        }): string | number | false;
        isTheRootClip?: boolean | undefined;
        listeners: Record<string, {
            funct: (ms: number, newState: any, options?: any) => void;
            onlyOnStateChange?: boolean | undefined;
            threshold: number;
            cavaDelta: number;
            roundTo: number;
        }>;
        previousTimeStamp: number;
        speed: number;
        pauseMoment: number;
        _setState(newState: StateStatus, options?: {}): void;
        handleSetState(_target: any, payload: {
            newState: StateStatus;
            options?: any;
        }): void;
        play(debug?: boolean): void;
        pause(): void;
        arm(): void;
        complete(): void;
        block(options?: {
            exception?: any;
        }): void;
        onPlay(): void;
        onWait(): void;
        playableProgress(fraction: number, millisecond: number): boolean;
        executionSpeed: string | number;
        step(timestamp: number, debug?: boolean): void;
        subscribe(id: string, funct: (ms: number, state: string, options: any) => void, threshold: number, roundTo: number, onlyOnStateChange?: boolean): void;
        unsubscribe(id: any): void;
        subscribeToDurationChange(funct: any): boolean;
        passiveAddition?: boolean | undefined;
        _calculateDuration(forceGroups?: any): boolean;
        _rebuildTree(): void;
        buildTree(): void;
        addIncident(descriptiveIncident: any, position?: any, options?: {
            check: boolean;
        }): any;
        moveIncident(input: any, position: any): any;
        removeIncident(input: any): any;
        handleSetDurationDynamic(target: any, payload: any): void;
        calculatedDuration: number;
        runTimeInfo: {
            currentMillisecond: number;
            state?: StateStatus | undefined;
        };
        resetDuration(): void;
        handleRecalcDuration(target: any, payload: any): boolean | PutMessageOnPipeRes | PutMessageOnPipeRes[];
        getLeafById(id: string, onlyDirectChild?: boolean): Leaf | null;
        getLeafPosition(id: string | number): any;
        handleGetLeafPosition(target: any, payload: {
            id: string;
        }): any;
        checkAddition(leaf: any, position: any): {
            result: boolean;
            reason: string;
        } | {
            result: boolean;
            reason?: undefined;
        };
        addChild(leaf: any, position: any): {
            result: boolean;
        } | {
            result: boolean;
            reason: string;
        };
        checkRemoveChild(id: any): {
            result: boolean;
            reason: string;
        } | {
            result: boolean;
            reason?: undefined;
        };
        removeChild(id: any): {
            result: boolean;
        };
        checkEditPosition(id: any, position: any): {
            result: boolean;
            reason: string;
        } | {
            result: boolean;
            reason?: undefined;
        };
        editPosition(id: any, position: any, bypassRecalcDuration?: boolean): {
            result: boolean;
        } | undefined;
        putMessageOnPipe(name: PutMessageOnPipeNames, payload: Record<string, unknown>, target: string | Record<string, any> | null, options?: {
            selfExecute?: boolean | undefined;
            direction?: _DIRECTIONS | undefined;
            positionDelta?: number | undefined;
        }): PutMessageOnPipeRes | PutMessageOnPipeRes[];
        putMsgOnPipeWithResult(name: PutMessageOnPipeNames, payload: Record<string, unknown>, target: string | Record<string, any> | null, options?: {
            selfExecute?: boolean | undefined;
            direction?: _DIRECTIONS | undefined;
            positionDelta?: number | undefined;
        } | undefined): {
            result: boolean;
        };
        handleGetPositionOnPyramidion(target: any, payload: {
            id: string;
            delta: number;
        }): string | number | boolean | {
            result: boolean;
        } | undefined;
        constructionIngredients: ConstructionIngredients;
        mcid: string;
        easing: (fraction: number) => number;
        plugin_channel_class: typeof Channel;
        attributesStaggers: any;
        propsStaggers: any;
        dynamicDurationValue: any;
        blockingWaitings: Record<string, BlockPayload>;
        _duration?: number | undefined;
        realClip: any;
        originalContextKey?: string | number | undefined;
        contexts: Record<string, Context>;
        attrs: any;
        _inheritedSelector: string | null;
        isNode: boolean;
        passive?: boolean | undefined;
        parentNode: any;
        props: any;
        children: Record<string | number, {
            id: string;
            position: number;
            leaf: any;
        }>;
        name: string;
        delay: number;
        hiatus: number;
        repeats: number;
        setNewDuration(newDuration: number): void;
        readonly hasParent: boolean;
        attachToNode(node: any): void;
        bypass(): string;
        readonly positionOnPyramidion: string | number | boolean | {
            result: boolean;
        } | undefined;
        getPositionOnPyramidion(delta?: number): string | number | boolean | {
            result: boolean;
        } | undefined;
        editAttributes(newAttrs: any): {
            result: true;
            execute?: (() => void) | undefined;
        } | {
            result: boolean;
            errors: any;
        } | {
            result: boolean;
            errors?: undefined;
        };
        editProperties(newProps: any): {
            result: boolean;
            errors?: undefined;
        } | {
            result: boolean;
            errors: any;
        } | {
            result: true;
            execute?: (() => void) | undefined;
        };
        clone(attrs?: {}, props?: {}): HTMLDescriptiveClip | CheckResult;
        selector(): any;
        getElements(_selector: string): string | boolean | any[] | {
            result: boolean;
        } | undefined;
        setupDynamicValues(): {
            attrs: {
                expression?: any;
                initParams?: InitParams | undefined;
            };
            props: {
                expression?: any;
                initParams?: InitParams | undefined;
            };
        };
        DescriptiveIncident: DescriptiveIncident;
        blockID: string | undefined;
        mc_plugin_npm_name: string;
        id?: string | undefined;
        getIncidentsByChannel(adjustMillisecond?: number, parentMillisecond?: number | null | undefined): {
            [x: string]: {
                millisecond: number;
                parentMillisecond: number | null | undefined;
                incident: MonoIncident | ExtendableClip | Group;
                id: string | undefined;
            }[];
        };
        setBlock(description?: string | undefined, options?: {
            blockId?: string | undefined;
        }): void;
        unblock(blockId?: string | null): void;
    };
    Incident: any;
    version: string;
    plugin: string;
    audio: AUDIO_OPTIONS;
    customClip: boolean;
    isClip: boolean;
    plugin_npm_name: string;
    Channel: typeof ClipChannel;
    ClassName: string;
    propsValidationRules: any;
    isGroup: boolean;
    attrsValidationRules: null;
} | {
    new (_attrs: any, _props: any): {};
} | undefined;

export { DescriptiveAudioClip as AudioClip, AudioEffect, AudioPlayback, BrowserClip, CSSEffect, DescriptiveCombo as Combo, CoreAudioClip, type Definition, MonoIncident as Effect, ExtendableCSSEffect, DescriptiveGroup as Group, HTMLDescriptiveClip as HTMLClip, JSX, MediaPlay as MediaPlayback, TimeCapsule, loadPlugin, setCore as setCSSCore, utils, version };
